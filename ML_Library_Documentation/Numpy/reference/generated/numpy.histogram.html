<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8">
    
    <title>numpy.histogram &mdash; NumPy v1.14 Manual</title>
    
    <link rel="stylesheet" type="text/css" href="../../_static/css/spc-bootstrap.css">
    <link rel="stylesheet" type="text/css" href="../../_static/css/spc-extend.css">
    <link rel="stylesheet" href="../../_static/scipy.css" type="text/css" >
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" >
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '1.14.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  false
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../_static/js/copybutton.js"></script>
    <link rel="author" title="About these documents" href="../../about.html" >
    <link rel="index" title="Index" href="../../genindex.html" >
    <link rel="search" title="Search" href="../../search.html" >
    <link rel="top" title="NumPy v1.14 Manual" href="../../index.html" >
    <link rel="up" title="Statistics" href="../routines.statistics.html" >
    <link rel="next" title="numpy.histogram2d" href="numpy.histogram2d.html" >
    <link rel="prev" title="numpy.cov" href="numpy.cov.html" > 
  </head>
  <body>

  <div class="container">
    <div class="header">
    </div>
  </div>


    <div class="container">
      <div class="main">
        
	<div class="row-fluid">
	  <div class="span12">
	    <div class="spc-navbar">
              
    <ul class="nav nav-pills pull-left">
        
        <li class="active"><a href="../../index.html">NumPy v1.14 Manual</a></li>
        

          <li class="active"><a href="../index.html" >NumPy Reference</a></li>
          <li class="active"><a href="../routines.html" >Routines</a></li>
          <li class="active"><a href="../routines.statistics.html" accesskey="U">Statistics</a></li> 
    </ul>
              
              
    <ul class="nav nav-pills pull-right">
      <li class="active">
        <a href="../../genindex.html" title="General Index"
           accesskey="I">index</a>
      </li>
      <li class="active">
        <a href="numpy.histogram2d.html" title="numpy.histogram2d"
           accesskey="N">next</a>
      </li>
      <li class="active">
        <a href="numpy.cov.html" title="numpy.cov"
           accesskey="P">previous</a>
      </li>
    </ul>
              
	    </div>
	  </div>
	</div>
        

	<div class="row-fluid">
      <div class="spc-rightsidebar span3">
        <div class="sphinxsidebarwrapper">
  <h4>Previous topic</h4>
  <p class="topless"><a href="numpy.cov.html"
                        title="previous chapter">numpy.cov</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="numpy.histogram2d.html"
                        title="next chapter">numpy.histogram2d</a></p>


        </div>
      </div>
          <div class="span9">
            
        <div class="bodywrapper">
          <div class="body" id="spc-section-body">
            
  <div class="section" id="numpy-histogram">
<h1>numpy.histogram<a class="headerlink" href="#numpy-histogram" title="Permalink to this headline">¶</a></h1>
<dl class="function">
<dt id="numpy.histogram">
<code class="descclassname">numpy.</code><code class="descname">histogram</code><span class="sig-paren">(</span><em>a</em>, <em>bins=10</em>, <em>range=None</em>, <em>normed=False</em>, <em>weights=None</em>, <em>density=None</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/numpy/numpy/blob/v1.14.0/numpy/lib/function_base.py#L432-L844"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#numpy.histogram" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the histogram of a set of data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>a</strong> : array_like</p>
<blockquote>
<div><p>Input data. The histogram is computed over the flattened array.</p>
</div></blockquote>
<p><strong>bins</strong> : int or sequence of scalars or str, optional</p>
<blockquote>
<div><p>If <em class="xref py py-obj">bins</em> is an int, it defines the number of equal-width
bins in the given range (10, by default). If <em class="xref py py-obj">bins</em> is a
sequence, it defines the bin edges, including the rightmost
edge, allowing for non-uniform bin widths.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.11.0.</span></p>
</div>
<p>If <em class="xref py py-obj">bins</em> is a string from the list below, <a class="reference internal" href="#numpy.histogram" title="numpy.histogram"><code class="xref py py-obj docutils literal"><span class="pre">histogram</span></code></a> will use
the method chosen to calculate the optimal bin width and
consequently the number of bins (see <em class="xref py py-obj">Notes</em> for more detail on
the estimators) from the data that falls within the requested
range. While the bin width will be optimal for the actual data
in the range, the number of bins will be computed to fill the
entire range, including the empty portions. For visualisation,
using the &#8216;auto&#8217; option is suggested. Weighted data is not
supported for automated bin size selection.</p>
<dl class="docutils">
<dt>&#8216;auto&#8217;</dt>
<dd><p class="first last">Maximum of the &#8216;sturges&#8217; and &#8216;fd&#8217; estimators. Provides good
all around performance.</p>
</dd>
<dt>&#8216;fd&#8217; (Freedman Diaconis Estimator)</dt>
<dd><p class="first last">Robust (resilient to outliers) estimator that takes into
account data variability and data size.</p>
</dd>
<dt>&#8216;doane&#8217;</dt>
<dd><p class="first last">An improved version of Sturges&#8217; estimator that works better
with non-normal datasets.</p>
</dd>
<dt>&#8216;scott&#8217;</dt>
<dd><p class="first last">Less robust estimator that that takes into account data
variability and data size.</p>
</dd>
<dt>&#8216;rice&#8217;</dt>
<dd><p class="first last">Estimator does not take variability into account, only data
size. Commonly overestimates number of bins required.</p>
</dd>
<dt>&#8216;sturges&#8217;</dt>
<dd><p class="first last">R&#8217;s default method, only accounts for data size. Only
optimal for gaussian data and underestimates number of bins
for large non-gaussian datasets.</p>
</dd>
<dt>&#8216;sqrt&#8217;</dt>
<dd><p class="first last">Square root (of data size) estimator, used by Excel and
other programs for its speed and simplicity.</p>
</dd>
</dl>
</div></blockquote>
<p><strong>range</strong> : (float, float), optional</p>
<blockquote>
<div><p>The lower and upper range of the bins.  If not provided, range
is simply <code class="docutils literal"><span class="pre">(a.min(),</span> <span class="pre">a.max())</span></code>.  Values outside the range are
ignored. The first element of the range must be less than or
equal to the second. <em class="xref py py-obj">range</em> affects the automatic bin
computation as well. While bin width is computed to be optimal
based on the actual data within <em class="xref py py-obj">range</em>, the bin count will fill
the entire range including portions containing no data.</p>
</div></blockquote>
<p><strong>normed</strong> : bool, optional</p>
<blockquote>
<div><p>This keyword is deprecated in NumPy 1.6.0 due to confusing/buggy
behavior. It will be removed in NumPy 2.0.0. Use the <code class="docutils literal"><span class="pre">density</span></code>
keyword instead. If <code class="docutils literal"><span class="pre">False</span></code>, the result will contain the
number of samples in each bin. If <code class="docutils literal"><span class="pre">True</span></code>, the result is the
value of the probability <em>density</em> function at the bin,
normalized such that the <em>integral</em> over the range is 1. Note
that this latter behavior is known to be buggy with unequal bin
widths; use <code class="docutils literal"><span class="pre">density</span></code> instead.</p>
</div></blockquote>
<p><strong>weights</strong> : array_like, optional</p>
<blockquote>
<div><p>An array of weights, of the same shape as <em class="xref py py-obj">a</em>.  Each value in
<em class="xref py py-obj">a</em> only contributes its associated weight towards the bin count
(instead of 1). If <em class="xref py py-obj">density</em> is True, the weights are
normalized, so that the integral of the density over the range
remains 1.</p>
</div></blockquote>
<p><strong>density</strong> : bool, optional</p>
<blockquote>
<div><p>If <code class="docutils literal"><span class="pre">False</span></code>, the result will contain the number of samples in
each bin. If <code class="docutils literal"><span class="pre">True</span></code>, the result is the value of the
probability <em>density</em> function at the bin, normalized such that
the <em>integral</em> over the range is 1. Note that the sum of the
histogram values will not be equal to 1 unless bins of unity
width are chosen; it is not a probability <em>mass</em> function.</p>
<p>Overrides the <code class="docutils literal"><span class="pre">normed</span></code> keyword if given.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>hist</strong> : array</p>
<blockquote>
<div><p>The values of the histogram. See <em class="xref py py-obj">density</em> and <em class="xref py py-obj">weights</em> for a
description of the possible semantics.</p>
</div></blockquote>
<p><strong>bin_edges</strong> : array of dtype float</p>
<blockquote class="last">
<div><p>Return the bin edges <code class="docutils literal"><span class="pre">(length(hist)+1)</span></code>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="numpy.histogramdd.html#numpy.histogramdd" title="numpy.histogramdd"><code class="xref py py-obj docutils literal"><span class="pre">histogramdd</span></code></a>, <a class="reference internal" href="numpy.bincount.html#numpy.bincount" title="numpy.bincount"><code class="xref py py-obj docutils literal"><span class="pre">bincount</span></code></a>, <a class="reference internal" href="numpy.searchsorted.html#numpy.searchsorted" title="numpy.searchsorted"><code class="xref py py-obj docutils literal"><span class="pre">searchsorted</span></code></a>, <a class="reference internal" href="numpy.digitize.html#numpy.digitize" title="numpy.digitize"><code class="xref py py-obj docutils literal"><span class="pre">digitize</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<p>All but the last (righthand-most) bin is half-open.  In other words,
if <em class="xref py py-obj">bins</em> is:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
</pre></div>
</div>
<p>then the first bin is <code class="docutils literal"><span class="pre">[1,</span> <span class="pre">2)</span></code> (including 1, but excluding 2) and
the second <code class="docutils literal"><span class="pre">[2,</span> <span class="pre">3)</span></code>.  The last bin, however, is <code class="docutils literal"><span class="pre">[3,</span> <span class="pre">4]</span></code>, which
<em>includes</em> 4.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.11.0.</span></p>
</div>
<p>The methods to estimate the optimal number of bins are well founded
in literature, and are inspired by the choices R provides for
histogram visualisation. Note that having the number of bins
proportional to <img class="math" src="../../_images/math/5ab9b8cbf042a4944594a5b3f6d522e780217090.svg" alt="n^{1/3}"/> is asymptotically optimal, which is
why it appears in most estimators. These are simply plug-in methods
that give good starting points for number of bins. In the equations
below, <img class="math" src="../../_images/math/293fb39e1b93282c804a86186e721b32f829f1b2.svg" alt="h"/> is the binwidth and <img class="math" src="../../_images/math/549aba88e5e775946bb32e433b2b397de0cdcb69.svg" alt="n_h"/> is the number of
bins. All estimators that compute bin counts are recast to bin width
using the <a class="reference internal" href="numpy.ptp.html#numpy.ptp" title="numpy.ptp"><code class="xref py py-obj docutils literal"><span class="pre">ptp</span></code></a> of the data. The final bin count is obtained from
<a href="#id1"><span class="problematic" id="id2">``</span></a>np.round(np.ceil(range / h))`.</p>
<dl class="docutils">
<dt>&#8216;Auto&#8217; (maximum of the &#8216;Sturges&#8217; and &#8216;FD&#8217; estimators)</dt>
<dd>A compromise to get a good value. For small datasets the Sturges
value will usually be chosen, while larger datasets will usually
default to FD.  Avoids the overly conservative behaviour of FD
and Sturges for small and large datasets respectively.
Switchover point is usually <img class="math" src="../../_images/math/8b8c98c8506df9bbf5b3a8ba640b2967943f1135.svg" alt="a.size \approx 1000"/>.</dd>
<dt>&#8216;FD&#8217; (Freedman Diaconis Estimator)</dt>
<dd><div class="first math">
<p><img src="../../_images/math/1a90ebe9917b1af799a6de20efe7b1c040be7c94.svg" alt="h = 2 \frac{IQR}{n^{1/3}}"/></p>
</div><p class="last">The binwidth is proportional to the interquartile range (IQR)
and inversely proportional to cube root of a.size. Can be too
conservative for small datasets, but is quite good for large
datasets. The IQR is very robust to outliers.</p>
</dd>
<dt>&#8216;Scott&#8217;</dt>
<dd><div class="first math">
<p><img src="../../_images/math/0d05809d032cc26458b6631d2c5faadafd99cc48.svg" alt="h = \sigma \sqrt[3]{\frac{24 * \sqrt{\pi}}{n}}"/></p>
</div><p class="last">The binwidth is proportional to the standard deviation of the
data and inversely proportional to cube root of <code class="docutils literal"><span class="pre">x.size</span></code>. Can
be too conservative for small datasets, but is quite good for
large datasets. The standard deviation is not very robust to
outliers. Values are very similar to the Freedman-Diaconis
estimator in the absence of outliers.</p>
</dd>
<dt>&#8216;Rice&#8217;</dt>
<dd><div class="first math">
<p><img src="../../_images/math/4144e11e0ec76ae1709bf38f3d7e1c074e198a09.svg" alt="n_h = 2n^{1/3}"/></p>
</div><p class="last">The number of bins is only proportional to cube root of
<code class="docutils literal"><span class="pre">a.size</span></code>. It tends to overestimate the number of bins and it
does not take into account data variability.</p>
</dd>
<dt>&#8216;Sturges&#8217;</dt>
<dd><div class="first math">
<p><img src="../../_images/math/ed00695d0ea6bc268d32c9ec3b175f82fbbbc8f6.svg" alt="n_h = \log _{2}n+1"/></p>
</div><p class="last">The number of bins is the base 2 log of <code class="docutils literal"><span class="pre">a.size</span></code>.  This
estimator assumes normality of data and is too conservative for
larger, non-normal datasets. This is the default method in R&#8217;s
<code class="docutils literal"><span class="pre">hist</span></code> method.</p>
</dd>
<dt>&#8216;Doane&#8217;</dt>
<dd><div class="first math">
<p><img src="../../_images/math/ae96bace88eef3d9cf5f9fef02f841e649fef22e.svg" alt="n_h = 1 + \log_{2}(n) +
            \log_{2}(1 + \frac{|g_1|}{\sigma_{g_1}})

g_1 = mean[(\frac{x - \mu}{\sigma})^3]

\sigma_{g_1} = \sqrt{\frac{6(n - 2)}{(n + 1)(n + 3)}}"/></p>
</div><p class="last">An improved version of Sturges&#8217; formula that produces better
estimates for non-normal datasets. This estimator attempts to
account for the skew of the data.</p>
</dd>
<dt>&#8216;Sqrt&#8217;</dt>
<dd><div class="first math">
<p><img src="../../_images/math/8598023dd62a8b7814e68840da2549498cc642b9.svg" alt="n_h = \sqrt n"/></p>
</div><p class="last">The simplest and fastest estimator. Only takes into account the
data size.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">bins</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="go">(array([0, 2, 1]), array([0, 1, 2, 3]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="n">bins</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span> <span class="n">density</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">(array([ 0.25,  0.25,  0.25,  0.25]), array([0, 1, 2, 3, 4]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]],</span> <span class="n">bins</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="go">(array([1, 4, 1]), array([0, 1, 2, 3]))</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hist</span><span class="p">,</span> <span class="n">bin_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hist</span>
<span class="go">array([ 0.5,  0. ,  0.5,  0. ,  0. ,  0.5,  0. ,  0.5,  0. ,  0.5])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hist</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
<span class="go">2.4999999999999996</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">hist</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">bin_edges</span><span class="p">))</span>
<span class="go">1.0</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.11.0.</span></p>
</div>
<p>Automated Bin Selection Methods example, using 2 peak random data
with 2000 points:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>  <span class="c1"># deterministic random data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">rng</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="mi">1000</span><span class="p">),</span>
<span class="gp">... </span>               <span class="n">rng</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">1000</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">)</span>  <span class="c1"># arguments are passed to np.histogram</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Histogram with &#39;auto&#39; bins&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<div class="figure">
<img alt="../../_images/numpy-histogram-1.png" src="../../_images/numpy-histogram-1.png" />
</div>
</dd></dl>

</div>


          </div>
        </div>
          </div>
        </div>
      </div>
    </div>

    <div class="container container-navbar-bottom">
      <div class="spc-navbar">
        
      </div>
    </div>
    <div class="container">
    <div class="footer">
    <div class="row-fluid">
    <ul class="inline pull-left">
      <li>
        &copy; Copyright 2008-2017, The SciPy community.
      </li>
      <li>
      Last updated on Jan 08, 2018.
      </li>
      <li>
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.5.3.
      </li>
    </ul>
    </div>
    </div>
    </div>
  </body>
</html>